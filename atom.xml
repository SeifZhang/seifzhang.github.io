<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SeifZhang&#39;s Blog</title>
  <subtitle>A girl，just a simple girl!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://seifzhang.jerrychia.com/"/>
  <updated>2016-06-28T07:49:50.833Z</updated>
  <id>http://seifzhang.jerrychia.com/</id>
  
  <author>
    <name>SeifZhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>方法集合</title>
    <link href="http://seifzhang.jerrychia.com/2016/06/23/1methods/"/>
    <id>http://seifzhang.jerrychia.com/2016/06/23/1methods/</id>
    <published>2016-06-23T07:56:51.238Z</published>
    <updated>2016-06-28T07:49:50.833Z</updated>
    
    <content type="html">&lt;h2 id=&quot;字符数组转换成字符串的方法&quot;&gt;&lt;a href=&quot;#字符数组转换成字符串的方法&quot; class=&quot;headerlink&quot; title=&quot;字符数组转换成字符串的方法&quot;&gt;&lt;/a&gt;字符数组转换成字符串的方法&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;char[] chs = { &amp;apos;a&amp;apos;, &amp;apos;b&amp;apos;, &amp;apos;c&amp;apos;, &amp;apos;d&amp;apos;, &amp;apos;e&amp;apos; };
String s1 = new String(chs);
String s2 = String.valueOf(chs);
StringBuffer sBuffer = new StringBuffer();
for (int i = 0; i &amp;lt; chs.length; i++) {
    sBuffer.append(chs[i]);
}
String s3 = sBuffer.toString();
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&quot;HashSet-的使用&quot;&gt;&lt;a href=&quot;#HashSet-的使用&quot; class=&quot;headerlink&quot; title=&quot;HashSet()的使用&quot;&gt;&lt;/a&gt;HashSet()的使用&lt;/h2&gt;&lt;p&gt;leetcode中&lt;strong&gt;T202&lt;/strong&gt;（happy number）和&lt;strong&gt;T217&lt;/strong&gt;,&lt;strong&gt;T219&lt;/strong&gt;（contains duplicate）都用到了.&lt;br&gt;HashSet 是 Set 接口的常用实现类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;`Set&amp;lt;Integer&amp;gt; set = new HashSet&amp;lt;Integer&amp;gt;();`    
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;它不允许出现重复元素；&lt;/li&gt;
&lt;li&gt;不保证集合中元素的顺序&lt;/li&gt;
&lt;li&gt;允许包含值为null的元素，但最多只能有一个null元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;HashMap-的使用&quot;&gt;&lt;a href=&quot;#HashMap-的使用&quot; class=&quot;headerlink&quot; title=&quot;HashMap()的使用&quot;&gt;&lt;/a&gt;HashMap()的使用&lt;/h2&gt;&lt;p&gt;leetcode中&lt;strong&gt;T219&lt;/strong&gt;（contains duplicate）用到了.&lt;br&gt;HashMap 是 Map 接口的常用实现类&lt;br&gt;    &lt;code&gt;Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();&lt;/code&gt;&lt;br&gt;存储实现：put(key,vlaue);&lt;br&gt;读取实现：get(key);&lt;br&gt;&lt;code&gt;Object put(K key,V value)&lt;/code&gt;&lt;br&gt;向集合中添加指定值与指定键映射关系。&lt;br&gt;&lt;code&gt;putAll(Map m)&lt;/code&gt;&lt;br&gt;将指定映射M的所有映射关系复制到此映射中，这些映射关系将替换此映射目前针对指定映射中所有键的所有映射关系。&lt;br&gt;&lt;code&gt;Object get(Object K)&lt;/code&gt;&lt;br&gt;返回指定键在此标识哈希映射中所映射的值，如果存在指定的键对象则返回与该键对应的值对象;否则返null。&lt;br&gt;&lt;code&gt;void clear()&lt;/code&gt;&lt;br&gt;移除集合中所有的映射关系。&lt;br&gt;&lt;code&gt;int size()&lt;/code&gt;&lt;br&gt;返回集合中的键-值映射关系个数。&lt;br&gt;&lt;code&gt;int hashCode()&lt;/code&gt;&lt;br&gt;返回调用映射的散列码。&lt;br&gt;&lt;code&gt;Object clone()&lt;/code&gt;&lt;br&gt;返回此 HashMap 实例的浅表复制：并不克隆键和值本身。&lt;br&gt;&lt;code&gt;boolean equals(Object obj)&lt;/code&gt;&lt;br&gt;如果obj是一个map并包含相同的映射，则返回true.&lt;br&gt;&lt;code&gt;boolean containsKey(Object K)&lt;/code&gt;&lt;br&gt;如果映射中包含了作为键的K，则返回true。&lt;br&gt;&lt;code&gt;boolean containsValue(Object value)&lt;/code&gt;&lt;br&gt;如果映射中包含了作为值的V，则返回true。&lt;br&gt;&lt;code&gt;Set &amp;gt; entrySet()&lt;/code&gt;&lt;br&gt;返回此映射所包含的映射关系的 collection视图。&lt;br&gt;&lt;code&gt;boolean isEmpty()&lt;/code&gt;&lt;br&gt;如果此映射不包含键-值映射关系，也就是说映射是空的，则返回true。&lt;br&gt;&lt;code&gt;Set keySet()&lt;/code&gt;&lt;br&gt;返回此映射中所包含的键的set视图。&lt;br&gt;&lt;code&gt;remove(Object K)&lt;/code&gt;&lt;br&gt;删除关键字等于K的映射关系。&lt;br&gt;&lt;code&gt;Collection values()&lt;/code&gt;&lt;br&gt;返回此映射所包含的值的collection视图,也就是值的集合。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args){    
     HashMap hs=new HashMap();       
     hs.put(&amp;quot;name&amp;quot;, &amp;quot;张三&amp;quot;);       
     hs.put(&amp;quot;sex&amp;quot;, &amp;quot;男&amp;quot;);       
     hs.put(&amp;quot;age&amp;quot;, &amp;quot;30&amp;quot;);       
    hs.put(&amp;quot;home&amp;quot;, &amp;quot;河北&amp;quot;);    
    //测试是否包含关键字&amp;quot;name&amp;quot; 
    System.out.println(hs.containsKey(&amp;quot;name&amp;quot;));//返回true 
    System.out.println(hs.get(&amp;quot;name&amp;quot;));//返回  张三 
    System.out.println(hs.entrySet());//返回  [home=河北, sex=男, age=30, name=张三]  System.out.println(hs.hashCode()); //返回7960688 
    System.out.println(hs.keySet()); //返回 [home, sex, age, name] 

    //1 测试entrySet().的用法
    Iterator it=hs.entrySet().iterator();//迭代程序  
    while(it.hasNext())  
    {      
        System.out.println(it.next());  
    }                  

    //2 Set keySet()返回关键字各值的集合    
    it=hs.keySet().iterator();     
    while(it.hasNext())     
    {      
        System.out.println(hs.get(it.next()));    
    }                
    //返回结果如下：  


    //3 测试  values()的用法
    it=hs.values().iterator();     
    while(it.hasNext())     
    {      
        System.out.println(it.next());     
    }                 
    //返回结果如下：     
}
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&quot;2-3-4的幂&quot;&gt;&lt;a href=&quot;#2-3-4的幂&quot; class=&quot;headerlink&quot; title=&quot;2,3,4的幂&quot;&gt;&lt;/a&gt;2,3,4的幂&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;T231，T326，T342&lt;/strong&gt;分别是有关2，3，4的幂的问题。用位操作，求3的幂不是用位操作。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;Queue的使用&quot;&gt;&lt;a href=&quot;#Queue的使用&quot; class=&quot;headerlink&quot; title=&quot;Queue的使用&quot;&gt;&lt;/a&gt;Queue的使用&lt;/h2&gt;&lt;p&gt;Queue接口与List、Set同一级别，都是继承了Collection接口。LinkedList实现了Queue接 口。Queue接口窄化了对LinkedList的方法的访问权限（即在方法中的参数类型如果是Queue时，就完全只能访问Queue接口所定义的方法 了，而不能直接访问 LinkedList的非Queue的方法），以使得只有恰当的方法才可以使用。BlockingQueue 继承了Queue接口。&lt;/p&gt;
&lt;p&gt;队列是一种数据结构．它有两个基本操作：在队列尾部加人一个元素，和从队列头部移除一个元素：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;add&lt;/strong&gt;        –增加一个元索                     如果队列已满，则抛出一个IIIegaISlabEepeplian异常&lt;br&gt;&lt;strong&gt;remove&lt;/strong&gt;   –移除并返回队列头部的元素    如果队列为空，则抛出一个NoSuchElementException异常&lt;br&gt;&lt;strong&gt;element&lt;/strong&gt;  –返回队列头部的元素             如果队列为空，则抛出一个NoSuchElementException异常&lt;br&gt;&lt;strong&gt;offer&lt;/strong&gt;       –添加一个元素并返回true       如果队列已满，则返回false&lt;br&gt;&lt;strong&gt;poll&lt;/strong&gt;         –移除并返问队列头部的元素    如果队列为空，则返回null&lt;br&gt;&lt;strong&gt;peek&lt;/strong&gt;       –返回队列头部的元素             如果队列为空，则返回null&lt;br&gt;&lt;strong&gt;put&lt;/strong&gt;         –添加一个元素                      如果队列满，则阻塞&lt;br&gt;&lt;strong&gt;take&lt;/strong&gt;        –移除并返回队列头部的元素     如果队列为空，则阻塞&lt;/p&gt;
&lt;p&gt;remove、element、offer 、poll、peek 其实是属于Queue接口。 &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;##寻找单链表中间节点，快慢指针法&lt;br&gt;第一步，有两个指针同时从头开始遍历。第二步，一个快指针一次走2步，一个慢指针一次走一步。第三步，快指针先到链表尾部，而慢指针则恰好到达链表中部。（快指针到链表尾部时，当链表长度为奇数时，慢指针指向的即是链表中间指针，当链表长度为偶数时，慢指针指向的结点和慢指针指向结点的下一个结点都是链表的中间结点）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void SearchMid(node* head, node* mid){
          node* temp = head;
          while(head-&amp;gt;next-&amp;gt;next != NULL)
          {
                 head = head-&amp;gt;next-&amp;gt;next;
                 temp = temp-&amp;gt;next;
                 mid=temp;
          }
}
// 1、寻找中间的指针start--mid--end，使用快慢指针
        ListNode slow = head;
        ListNode fast = head;
        ListNode mid = null;
        while (fast != null &amp;amp;&amp;amp; fast.next != null) {// 循环条件缺一不可（缺少程序会崩溃），链表节点个数可能为为奇数或偶数
            slow = slow.next;// 慢指针走一步
            fast = fast.next.next;// 快指针走两步
        }
        mid = slow;
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;##对数字各位相加&lt;br&gt;&lt;strong&gt;T202与T258&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public int add(int num) {
    int sum = 0;
    while (num != 0) {
        sum += num % 10;
        num = num / 10;
    }
    return sum;
}

// 另一种使数字中各位上数字相加的方法
public int add1(int num) {
    String s = String.valueOf(num);
    char[] chs = s.toCharArray();
    int sum = 0;
    for (int i = 0; i &amp;lt; chs.length; i++) {
        sum += chs[i] - &amp;apos;0&amp;apos;;
    }
    return sum;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;字符数组转换成字符串的方法&quot;&gt;&lt;a href=&quot;#字符数组转换成字符串的方法&quot; class=&quot;headerlink&quot; title=&quot;字符数组转换成字符串的方法&quot;&gt;&lt;/a&gt;字符数组转换成字符串的方法&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;char[] chs = { &amp;ap
    
    </summary>
    
      <category term="Seif's Summery" scheme="http://seifzhang.jerrychia.com/categories/Seif-s-Summery/"/>
    
    
      <category term="文章" scheme="http://seifzhang.jerrychia.com/tags/%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>Coding350_Intersection_of_Two_Arrays_II</title>
    <link href="http://seifzhang.jerrychia.com/2016/06/22/leetCode-OJ-350/"/>
    <id>http://seifzhang.jerrychia.com/2016/06/22/leetCode-OJ-350/</id>
    <published>2016-06-22T03:12:00.000Z</published>
    <updated>2016-06-28T08:39:53.576Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Algorithm-Description&quot;&gt;&lt;a href=&quot;#Algorithm-Description&quot; class=&quot;headerlink&quot; title=&quot;Algorithm Description&quot;&gt;&lt;/a&gt;Algorithm Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Given two arrays, write a function to compute their intersection.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;br&gt;Given nums1 = &lt;code&gt;[1, 2, 2, 1]&lt;/code&gt;, nums2 = &lt;code&gt;[2, 2]&lt;/code&gt;, return &lt;code&gt;[2, 2]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Each element in the result should appear as many times as it shows in both arrays.&lt;/li&gt;
&lt;li&gt;The result can be in any order.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Follow up:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What if the given array is already sorted? How would you optimize your algorithm?&lt;/li&gt;
&lt;li&gt;What if nums1’s size is small compared to nums2’s size? Which algorithm is better?&lt;/li&gt;
&lt;li&gt;What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;My-Algorithm&quot;&gt;&lt;a href=&quot;#My-Algorithm&quot; class=&quot;headerlink&quot; title=&quot;My Algorithm&quot;&gt;&lt;/a&gt;My Algorithm&lt;/h2&gt;&lt;h3 id=&quot;idea&quot;&gt;&lt;a href=&quot;#idea&quot; class=&quot;headerlink&quot; title=&quot;idea:&quot;&gt;&lt;/a&gt;idea:&lt;/h3&gt;&lt;hr&gt;
&lt;h3 id=&quot;code&quot;&gt;&lt;a href=&quot;#code&quot; class=&quot;headerlink&quot; title=&quot;code:&quot;&gt;&lt;/a&gt;code:&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;import java.util.ArrayList;
import java.util.Arrays;
public class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
        if (nums1.length == 0)
            return nums1;
        if (nums2.length == 0)
            return nums2;
        Arrays.sort(nums1);
        Arrays.sort(nums2);

        ArrayList&amp;lt;Integer&amp;gt; myList = new ArrayList&amp;lt;Integer&amp;gt;();
        int i = 0, j = 0;
        while (i &amp;lt; nums1.length &amp;amp;&amp;amp; j &amp;lt; nums2.length) {
            if (nums1[i] &amp;lt; nums2[j]) {
                i++;
            } else if (nums1[i] &amp;gt; nums2[j]) {
                j++;
            } else {
                myList.add(nums1[i]);
                i++;
                j++;
            }
        }
        int[] result = new int[myList.size()];
        int k = 0;
        for (Integer num : myList) {
            result[k++] = num;
        }
        return result;
    }
    // 此法不能用
    public int[] intersect1(int[] nums1, int[] nums2) {
        if (nums1.length == 0)
            return nums1;
        if (nums2.length == 0)
            return nums2;
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        Hashtable&amp;lt;Integer, Integer&amp;gt; numbers = new Hashtable&amp;lt;Integer, Integer&amp;gt;();
        ArrayList&amp;lt;Integer&amp;gt; myList = new ArrayList&amp;lt;Integer&amp;gt;();
        for (int i = 0; i &amp;lt; nums1.length; i++) {
            numbers.put(nums1[i], i);
        }
        for (int j = 0; j &amp;lt; nums2.length; j++) {
            if (numbers.containsKey(nums2[j])) {
                myList.add(nums2[j]);
            }
        }
        int[] result = new int[myList.size()];
        int i = 0;
        for (Integer num : myList) {
            result[i++] = num;
        }
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Algorithm-Description&quot;&gt;&lt;a href=&quot;#Algorithm-Description&quot; class=&quot;headerlink&quot; title=&quot;Algorithm Description&quot;&gt;&lt;/a&gt;Algorithm Description&lt;/
    
    </summary>
    
      <category term="LeetCode" scheme="http://seifzhang.jerrychia.com/categories/LeetCode/"/>
    
    
      <category term="Hash Table" scheme="http://seifzhang.jerrychia.com/tags/Hash-Table/"/>
    
      <category term="Two Pointers" scheme="http://seifzhang.jerrychia.com/tags/Two-Pointers/"/>
    
      <category term="Sort" scheme="http://seifzhang.jerrychia.com/tags/Sort/"/>
    
      <category term="Binary Search" scheme="http://seifzhang.jerrychia.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>Coding349_Intersection_of_Two_Arrays</title>
    <link href="http://seifzhang.jerrychia.com/2016/06/22/leetCode-OJ-349/"/>
    <id>http://seifzhang.jerrychia.com/2016/06/22/leetCode-OJ-349/</id>
    <published>2016-06-22T03:10:00.000Z</published>
    <updated>2016-06-28T08:20:58.599Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Algorithm-Description&quot;&gt;&lt;a href=&quot;#Algorithm-Description&quot; class=&quot;headerlink&quot; title=&quot;Algorithm Description&quot;&gt;&lt;/a&gt;Algorithm Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Given two arrays, write a function to compute their intersection.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;br&gt;Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Each element in the result must be unique.&lt;/li&gt;
&lt;li&gt;The result can be in any order.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;My-Algorithm&quot;&gt;&lt;a href=&quot;#My-Algorithm&quot; class=&quot;headerlink&quot; title=&quot;My Algorithm&quot;&gt;&lt;/a&gt;My Algorithm&lt;/h2&gt;&lt;h3 id=&quot;idea&quot;&gt;&lt;a href=&quot;#idea&quot; class=&quot;headerlink&quot; title=&quot;idea:&quot;&gt;&lt;/a&gt;idea:&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;结果中每个元素是唯一的，可以想到set&lt;br&gt;结果中顺序不要求相同&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&quot;code&quot;&gt;&lt;a href=&quot;#code&quot; class=&quot;headerlink&quot; title=&quot;code:&quot;&gt;&lt;/a&gt;code:&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

public class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        Set&amp;lt;Integer&amp;gt; set = new HashSet&amp;lt;&amp;gt;();
        Set&amp;lt;Integer&amp;gt; interset = new HashSet&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt; nums1.length; i++) {
            if (!set.contains(nums1[i])) {
                set.add(nums1[i]);
            }
        }
        for (int j = 0; j &amp;lt; nums2.length; j++) {
            if (set.contains(nums2[j])) {
                interset.add(nums2[j]);
            }
        }
        int[] result = new int[interset.size()];
        int i = 0;
        for (Integer num : interset) {
            result[i++] = num;
        }
        return result;
    }

    // 别人提交的方法，觉得好，就拿来用了
    public int[] intersection1(int[] nums1, int[] nums2) {
        Set&amp;lt;Integer&amp;gt; set = new HashSet&amp;lt;&amp;gt;();
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        int i = 0;
        int j = 0;
        while (i &amp;lt; nums1.length &amp;amp;&amp;amp; j &amp;lt; nums2.length) {
            if (nums1[i] &amp;lt; nums2[j]) {
                i++;
            } else if (nums1[i] &amp;gt; nums2[j]) {
                j++;
            } else {
                set.add(nums1[i]);
                i++;
                j++;
            }
        }
        int[] result = new int[set.size()];
        int k = 0;
        for (Integer num : set) {
            result[k++] = num;
        }
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Algorithm-Description&quot;&gt;&lt;a href=&quot;#Algorithm-Description&quot; class=&quot;headerlink&quot; title=&quot;Algorithm Description&quot;&gt;&lt;/a&gt;Algorithm Description&lt;/
    
    </summary>
    
      <category term="LeetCode" scheme="http://seifzhang.jerrychia.com/categories/LeetCode/"/>
    
    
      <category term="Hash Table" scheme="http://seifzhang.jerrychia.com/tags/Hash-Table/"/>
    
      <category term="Two Pointers" scheme="http://seifzhang.jerrychia.com/tags/Two-Pointers/"/>
    
      <category term="Sort" scheme="http://seifzhang.jerrychia.com/tags/Sort/"/>
    
      <category term="Binary Search" scheme="http://seifzhang.jerrychia.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>Coding345_Reverse_Vowels_of_a_String</title>
    <link href="http://seifzhang.jerrychia.com/2016/06/22/leetCode-OJ-345/"/>
    <id>http://seifzhang.jerrychia.com/2016/06/22/leetCode-OJ-345/</id>
    <published>2016-06-22T03:08:00.000Z</published>
    <updated>2016-06-28T07:07:19.776Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Algorithm-Description&quot;&gt;&lt;a href=&quot;#Algorithm-Description&quot; class=&quot;headerlink&quot; title=&quot;Algorithm Description&quot;&gt;&lt;/a&gt;Algorithm Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Write a function that takes a string as input and reverse only the vowels of a string.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;br&gt;Given s = “hello”, return “holle”.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;br&gt;Given s = “leetcode”, return “leotcede”.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;My-Algorithm&quot;&gt;&lt;a href=&quot;#My-Algorithm&quot; class=&quot;headerlink&quot; title=&quot;My Algorithm&quot;&gt;&lt;/a&gt;My Algorithm&lt;/h2&gt;&lt;h3 id=&quot;idea&quot;&gt;&lt;a href=&quot;#idea&quot; class=&quot;headerlink&quot; title=&quot;idea:&quot;&gt;&lt;/a&gt;idea:&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;反转一个字符串中的元音&lt;br&gt;双指针问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&quot;code&quot;&gt;&lt;a href=&quot;#code&quot; class=&quot;headerlink&quot; title=&quot;code:&quot;&gt;&lt;/a&gt;code:&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;public class Solution {
   public String reverseVowels(String s) {
        char[] chs = s.toCharArray();
        int i = 0, j = chs.length - 1;
        while (i &amp;lt;= j) {
            if (isVowel(chs[i]) &amp;amp;&amp;amp; isVowel(chs[j])) {
                char temp = chs[i];
                chs[i] = chs[j];
                chs[j] = temp;
                i++;
                j--;
            } else if (!isVowel(chs[i])) {
                i++;
            } else if (!isVowel(chs[j])) {
                j--;
            } else {
                i++;
                j--;
            }
        }
        StringBuffer sb = new StringBuffer();
        for (int j1 = 0; j1 &amp;lt; chs.length; j1++) {
            sb.append(chs[j1]);
        }
        return sb.toString();
    }

    public static boolean isVowel(char ch) {
        char[] chs = { &amp;apos;a&amp;apos;, &amp;apos;e&amp;apos;, &amp;apos;i&amp;apos;, &amp;apos;o&amp;apos;, &amp;apos;u&amp;apos;,&amp;apos;A&amp;apos;,&amp;apos;E&amp;apos;,&amp;apos;I&amp;apos;,&amp;apos;O&amp;apos;,&amp;apos;U&amp;apos; };
        for (int i = 0; i &amp;lt; chs.length; i++) {
            if (chs[i] == ch) {
                return true;
            }
        }
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Algorithm-Description&quot;&gt;&lt;a href=&quot;#Algorithm-Description&quot; class=&quot;headerlink&quot; title=&quot;Algorithm Description&quot;&gt;&lt;/a&gt;Algorithm Description&lt;/
    
    </summary>
    
      <category term="LeetCode" scheme="http://seifzhang.jerrychia.com/categories/LeetCode/"/>
    
    
      <category term="Two Pointers" scheme="http://seifzhang.jerrychia.com/tags/Two-Pointers/"/>
    
      <category term="String" scheme="http://seifzhang.jerrychia.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Coding344_Reverse_String</title>
    <link href="http://seifzhang.jerrychia.com/2016/06/22/leetCode-OJ-344/"/>
    <id>http://seifzhang.jerrychia.com/2016/06/22/leetCode-OJ-344/</id>
    <published>2016-06-22T03:06:00.000Z</published>
    <updated>2016-06-23T07:56:41.546Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Algorithm-Description&quot;&gt;&lt;a href=&quot;#Algorithm-Description&quot; class=&quot;headerlink&quot; title=&quot;Algorithm Description&quot;&gt;&lt;/a&gt;Algorithm Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Write a function that takes a string as input and returns the string reversed.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;br&gt;Given s = “hello”, return “olleh”.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;My-Algorithm&quot;&gt;&lt;a href=&quot;#My-Algorithm&quot; class=&quot;headerlink&quot; title=&quot;My Algorithm&quot;&gt;&lt;/a&gt;My Algorithm&lt;/h2&gt;&lt;h3 id=&quot;idea&quot;&gt;&lt;a href=&quot;#idea&quot; class=&quot;headerlink&quot; title=&quot;idea:&quot;&gt;&lt;/a&gt;idea:&lt;/h3&gt;&lt;hr&gt;
&lt;h3 id=&quot;code&quot;&gt;&lt;a href=&quot;#code&quot; class=&quot;headerlink&quot; title=&quot;code:&quot;&gt;&lt;/a&gt;code:&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;public class Solution {
    //直接用StringBuffer类中的reverse()函数
    public String reverseString1(String s) {
        StringBuffer sb = new StringBuffer(s);
        sb.reverse();
        return sb.toString();
    }
    //用两个指针
    public String reverseString(String s) {
        char[] chs = s.toCharArray();
        int i = 0;
        int j = chs.length - 1;
        while (i &amp;lt; j) {
            char temp = chs[i];
            chs[i] = chs[j];
            chs[j] = temp;
            i++;
            j--;
        }
        //字符数组变成字符串的用法
        // return new String(chs);
        return String.valueOf(chs);
    }
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Algorithm-Description&quot;&gt;&lt;a href=&quot;#Algorithm-Description&quot; class=&quot;headerlink&quot; title=&quot;Algorithm Description&quot;&gt;&lt;/a&gt;Algorithm Description&lt;/
    
    </summary>
    
      <category term="LeetCode" scheme="http://seifzhang.jerrychia.com/categories/LeetCode/"/>
    
    
      <category term="Two Pointers" scheme="http://seifzhang.jerrychia.com/tags/Two-Pointers/"/>
    
      <category term="String" scheme="http://seifzhang.jerrychia.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Coding342_Power_of_Four</title>
    <link href="http://seifzhang.jerrychia.com/2016/06/22/leetCode-OJ-342/"/>
    <id>http://seifzhang.jerrychia.com/2016/06/22/leetCode-OJ-342/</id>
    <published>2016-06-22T03:04:00.000Z</published>
    <updated>2016-06-23T13:37:46.941Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Algorithm-Description&quot;&gt;&lt;a href=&quot;#Algorithm-Description&quot; class=&quot;headerlink&quot; title=&quot;Algorithm Description&quot;&gt;&lt;/a&gt;Algorithm Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Given an integer (signed 32 bits), write a function to check whether it is a power of 4.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;br&gt;Given num = 16, return true. Given num = 5, return false.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow up:&lt;/strong&gt; Could you solve it without loops/recursion?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;My-Algorithm&quot;&gt;&lt;a href=&quot;#My-Algorithm&quot; class=&quot;headerlink&quot; title=&quot;My Algorithm&quot;&gt;&lt;/a&gt;My Algorithm&lt;/h2&gt;&lt;h3 id=&quot;idea&quot;&gt;&lt;a href=&quot;#idea&quot; class=&quot;headerlink&quot; title=&quot;idea:&quot;&gt;&lt;/a&gt;idea:&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;不能用求2的幂的方法来求，因为第一个是1的情况也有可能是2的幂，而不是4的幂。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&quot;code&quot;&gt;&lt;a href=&quot;#code&quot; class=&quot;headerlink&quot; title=&quot;code:&quot;&gt;&lt;/a&gt;code:&lt;/h3&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Algorithm-Description&quot;&gt;&lt;a href=&quot;#Algorithm-Description&quot; class=&quot;headerlink&quot; title=&quot;Algorithm Description&quot;&gt;&lt;/a&gt;Algorithm Description&lt;/
    
    </summary>
    
      <category term="LeetCode" scheme="http://seifzhang.jerrychia.com/categories/LeetCode/"/>
    
    
      <category term="Bit Manipulation" scheme="http://seifzhang.jerrychia.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>Coding326_Power_of_Three</title>
    <link href="http://seifzhang.jerrychia.com/2016/06/22/leetCode-OJ-326/"/>
    <id>http://seifzhang.jerrychia.com/2016/06/22/leetCode-OJ-326/</id>
    <published>2016-06-22T03:02:00.000Z</published>
    <updated>2016-06-24T01:19:02.054Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Algorithm-Description&quot;&gt;&lt;a href=&quot;#Algorithm-Description&quot; class=&quot;headerlink&quot; title=&quot;Algorithm Description&quot;&gt;&lt;/a&gt;Algorithm Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Given an integer, write a function to determine if it is a power of three.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow up:&lt;/strong&gt;&lt;br&gt;Could you do it without using any loop / recursion?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;My-Algorithm&quot;&gt;&lt;a href=&quot;#My-Algorithm&quot; class=&quot;headerlink&quot; title=&quot;My Algorithm&quot;&gt;&lt;/a&gt;My Algorithm&lt;/h2&gt;&lt;h3 id=&quot;idea&quot;&gt;&lt;a href=&quot;#idea&quot; class=&quot;headerlink&quot; title=&quot;idea:&quot;&gt;&lt;/a&gt;idea:&lt;/h3&gt;&lt;p&gt;3^0=1,3^1=3,3^2=9,3^3=27,3^4=81,3^5=243…&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;code&quot;&gt;&lt;a href=&quot;#code&quot; class=&quot;headerlink&quot; title=&quot;code:&quot;&gt;&lt;/a&gt;code:&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;public class Solution {
    public boolean isPowerOfThree(int n) {
      if (n &amp;lt; 0) {
            return false;
        }
        double ret = Math.log10(n) / Math.log10(3);
        // 如果n=5,ret=1.4649735207179273,ret%1肯定不等于0
        //System.out.println(ret);
        if (ret % 1 == 0) {
            return true;
        } else {
            return false;
        }
        // 网上的一行代码
        // 1162261467 is 3^19, 3^20 is bigger than int
        // return ( n&amp;gt;0 &amp;amp;&amp;amp; 1162261467%n==0);
    }
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Algorithm-Description&quot;&gt;&lt;a href=&quot;#Algorithm-Description&quot; class=&quot;headerlink&quot; title=&quot;Algorithm Description&quot;&gt;&lt;/a&gt;Algorithm Description&lt;/
    
    </summary>
    
      <category term="LeetCode" scheme="http://seifzhang.jerrychia.com/categories/LeetCode/"/>
    
    
      <category term="Math" scheme="http://seifzhang.jerrychia.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Coding303_Range_Sum_Query - Immutable</title>
    <link href="http://seifzhang.jerrychia.com/2016/06/22/leetCode-OJ-303/"/>
    <id>http://seifzhang.jerrychia.com/2016/06/22/leetCode-OJ-303/</id>
    <published>2016-06-22T03:00:00.000Z</published>
    <updated>2016-06-28T06:37:00.949Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Algorithm-Description&quot;&gt;&lt;a href=&quot;#Algorithm-Description&quot; class=&quot;headerlink&quot; title=&quot;Algorithm Description&quot;&gt;&lt;/a&gt;Algorithm Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Given nums = [-2, 0, 3, -5, 2, -1]

sumRange(0, 2) -&amp;gt; 1
sumRange(2, 5) -&amp;gt; -1
sumRange(0, 5) -&amp;gt; -3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.    You may assume that the array does not change.
2.    There are many calls to sumRange function.
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;My-Algorithm&quot;&gt;&lt;a href=&quot;#My-Algorithm&quot; class=&quot;headerlink&quot; title=&quot;My Algorithm&quot;&gt;&lt;/a&gt;My Algorithm&lt;/h2&gt;&lt;h3 id=&quot;idea&quot;&gt;&lt;a href=&quot;#idea&quot; class=&quot;headerlink&quot; title=&quot;idea:&quot;&gt;&lt;/a&gt;idea:&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在本题中，sumRange可能会被调用多次，因此如果每次调用时才对下标区间的元素进行累加，会导致效率低下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class NumArray {
    public int[] nums;
    public NumArray(int[] nums) {
        this.nums = nums;
    }
    public int sumRange(int i, int j) {
        int result = 0;
        for (int counter = i; counter &amp;lt;= j; counter++) {
            result += nums[counter];
        }
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以该方法效率低下&lt;br&gt;在&lt;br&gt;    public class NumArray {&lt;br&gt;        public NumArray(int[] nums) {&lt;br&gt;        }&lt;br&gt;        public int sumRange(int i, int j) {&lt;br&gt;        }&lt;br&gt;    }&lt;br&gt;中，给出了NumArray的构造函数，所以可以在构造函数内就计算从第一个元素到当前元素所有元素的和，保存到数组sums的对应位置中，在函数sumRange中就可以很方便地算出题目中要求的结果了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&quot;code&quot;&gt;&lt;a href=&quot;#code&quot; class=&quot;headerlink&quot; title=&quot;code:&quot;&gt;&lt;/a&gt;code:&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;public class NumArray {
    private int[] dp;
    public NumArray(int[] nums) {
        dp = new int[nums.length];
        int sum = 0;
        for (int i = 0; i &amp;lt; nums.length; i++) {
            sum += nums[i];
            dp[i] = sum;
        }
    }

    public int sumRange(int i, int j) {
        return i == 0 ? dp[j] : dp[j] - dp[i - 1];
    }
}


// Your NumArray object will be instantiated and called as such:
// NumArray numArray = new NumArray(nums);
// numArray.sumRange(0, 1);
// numArray.sumRange(1, 2);
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Algorithm-Description&quot;&gt;&lt;a href=&quot;#Algorithm-Description&quot; class=&quot;headerlink&quot; title=&quot;Algorithm Description&quot;&gt;&lt;/a&gt;Algorithm Description&lt;/
    
    </summary>
    
      <category term="LeetCode" scheme="http://seifzhang.jerrychia.com/categories/LeetCode/"/>
    
    
      <category term="Dynamic Programming" scheme="http://seifzhang.jerrychia.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>Coding299_Bulls_and_Cows</title>
    <link href="http://seifzhang.jerrychia.com/2016/06/21/leetCode-OJ-299/"/>
    <id>http://seifzhang.jerrychia.com/2016/06/21/leetCode-OJ-299/</id>
    <published>2016-06-21T02:58:00.000Z</published>
    <updated>2016-06-23T07:18:23.835Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Algorithm-Description&quot;&gt;&lt;a href=&quot;#Algorithm-Description&quot; class=&quot;headerlink&quot; title=&quot;Algorithm Description&quot;&gt;&lt;/a&gt;Algorithm Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;You are playing the following &lt;a href=&quot;https://en.wikipedia.org/wiki/Bulls_and_Cows&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Bulls and Cows&lt;/a&gt; game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called “bulls”) and how many digits match the secret number but locate in the wrong position (called “cows”). Your friend will use successive guesses and hints to eventually derive the secret number.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Secret number:  &amp;quot;1807&amp;quot;
Friend&amp;apos;s guess: &amp;quot;7810&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Hint: &lt;code&gt;1&lt;/code&gt; bull and &lt;code&gt;3&lt;/code&gt; cows. (The bull is &lt;code&gt;8&lt;/code&gt;, the cows are &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;7&lt;/code&gt;.)&lt;br&gt;Write a function to return a hint according to the secret number and friend’s guess, use &lt;code&gt;A&lt;/code&gt; to indicate the bulls and &lt;code&gt;B&lt;/code&gt; to indicate the cows. In the above example, your function should return &lt;code&gt;&amp;quot;1A3B&amp;quot;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Please note that both secret number and friend’s guess may contain duplicate digits, for example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Secret number:  &amp;quot;1123&amp;quot;
Friend&amp;apos;s guess: &amp;quot;0111&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this case, the 1st &lt;code&gt;1&lt;/code&gt; in friend’s guess is a bull, the 2nd or 3rd 1 is a cow, and your function should return &lt;code&gt;&amp;quot;1A1B&amp;quot;&lt;/code&gt;.&lt;br&gt;You may assume that the secret number and your friend’s guess only contain digits, and their lengths are always equal.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;My-Algorithm&quot;&gt;&lt;a href=&quot;#My-Algorithm&quot; class=&quot;headerlink&quot; title=&quot;My Algorithm&quot;&gt;&lt;/a&gt;My Algorithm&lt;/h2&gt;&lt;h3 id=&quot;idea&quot;&gt;&lt;a href=&quot;#idea&quot; class=&quot;headerlink&quot; title=&quot;idea:&quot;&gt;&lt;/a&gt;idea:&lt;/h3&gt;&lt;hr&gt;
&lt;h3 id=&quot;code&quot;&gt;&lt;a href=&quot;#code&quot; class=&quot;headerlink&quot; title=&quot;code:&quot;&gt;&lt;/a&gt;code:&lt;/h3&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Algorithm-Description&quot;&gt;&lt;a href=&quot;#Algorithm-Description&quot; class=&quot;headerlink&quot; title=&quot;Algorithm Description&quot;&gt;&lt;/a&gt;Algorithm Description&lt;/
    
    </summary>
    
      <category term="LeetCode" scheme="http://seifzhang.jerrychia.com/categories/LeetCode/"/>
    
    
      <category term="Hash Table" scheme="http://seifzhang.jerrychia.com/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>Coding292_Nim_Game</title>
    <link href="http://seifzhang.jerrychia.com/2016/06/21/leetCode-OJ-292/"/>
    <id>http://seifzhang.jerrychia.com/2016/06/21/leetCode-OJ-292/</id>
    <published>2016-06-21T02:56:00.000Z</published>
    <updated>2016-06-23T07:13:39.588Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Algorithm-Description&quot;&gt;&lt;a href=&quot;#Algorithm-Description&quot; class=&quot;headerlink&quot; title=&quot;Algorithm Description&quot;&gt;&lt;/a&gt;Algorithm Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.&lt;/p&gt;
&lt;p&gt;Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.&lt;/p&gt;
&lt;p&gt;For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hint:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;   If there are 5 stones in the heap, could you figure out a way to remove the stones such that you will always be the winner?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;My-Algorithm&quot;&gt;&lt;a href=&quot;#My-Algorithm&quot; class=&quot;headerlink&quot; title=&quot;My Algorithm&quot;&gt;&lt;/a&gt;My Algorithm&lt;/h2&gt;&lt;h3 id=&quot;idea&quot;&gt;&lt;a href=&quot;#idea&quot; class=&quot;headerlink&quot; title=&quot;idea:&quot;&gt;&lt;/a&gt;idea:&lt;/h3&gt;&lt;hr&gt;
&lt;h3 id=&quot;code&quot;&gt;&lt;a href=&quot;#code&quot; class=&quot;headerlink&quot; title=&quot;code:&quot;&gt;&lt;/a&gt;code:&lt;/h3&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Algorithm-Description&quot;&gt;&lt;a href=&quot;#Algorithm-Description&quot; class=&quot;headerlink&quot; title=&quot;Algorithm Description&quot;&gt;&lt;/a&gt;Algorithm Description&lt;/
    
    </summary>
    
      <category term="LeetCode" scheme="http://seifzhang.jerrychia.com/categories/LeetCode/"/>
    
    
      <category term="Brainteaser" scheme="http://seifzhang.jerrychia.com/tags/Brainteaser/"/>
    
  </entry>
  
  <entry>
    <title>Coding290_Word_Pattern</title>
    <link href="http://seifzhang.jerrychia.com/2016/06/21/leetCode-OJ-290/"/>
    <id>http://seifzhang.jerrychia.com/2016/06/21/leetCode-OJ-290/</id>
    <published>2016-06-21T02:54:00.000Z</published>
    <updated>2016-06-28T06:37:08.766Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Algorithm-Description&quot;&gt;&lt;a href=&quot;#Algorithm-Description&quot; class=&quot;headerlink&quot; title=&quot;Algorithm Description&quot;&gt;&lt;/a&gt;Algorithm Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Given a &lt;code&gt;pattern&lt;/code&gt; and a string &lt;code&gt;str&lt;/code&gt;, find if &lt;code&gt;str&lt;/code&gt; follows the same pattern.&lt;/p&gt;
&lt;p&gt;Here &lt;strong&gt;follow&lt;/strong&gt; means a full match, such that there is a bijection between a letter in &lt;code&gt;pattern&lt;/code&gt; and a &lt;strong&gt;non-empty&lt;/strong&gt; word in &lt;code&gt;str&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Examples:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;pattern = &lt;code&gt;&amp;quot;abba&amp;quot;&lt;/code&gt;, str = &lt;code&gt;&amp;quot;dog cat cat dog&amp;quot;&lt;/code&gt;should return true.&lt;/li&gt;
&lt;li&gt;pattern = &lt;code&gt;&amp;quot;abba&amp;quot;&lt;/code&gt;, str = &lt;code&gt;&amp;quot;dog cat cat fish&amp;quot;&lt;/code&gt; should return false.&lt;/li&gt;
&lt;li&gt;pattern = &lt;code&gt;&amp;quot;aaaa&amp;quot;&lt;/code&gt;, str = &lt;code&gt;&amp;quot;dog cat cat dog&amp;quot;&lt;/code&gt; should return false.&lt;/li&gt;
&lt;li&gt;pattern = &lt;code&gt;&amp;quot;abba&amp;quot;&lt;/code&gt;, str = &lt;code&gt;&amp;quot;dog dog dog dog&amp;quot;&lt;/code&gt; should return false.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Notes:&lt;/strong&gt;&lt;br&gt;You may assume &lt;code&gt;pattern&lt;/code&gt; contains only lowercase letters, and &lt;code&gt;str&lt;/code&gt; contains lowercase letters separated by a single space.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;My-Algorithm&quot;&gt;&lt;a href=&quot;#My-Algorithm&quot; class=&quot;headerlink&quot; title=&quot;My Algorithm&quot;&gt;&lt;/a&gt;My Algorithm&lt;/h2&gt;&lt;h3 id=&quot;idea&quot;&gt;&lt;a href=&quot;#idea&quot; class=&quot;headerlink&quot; title=&quot;idea:&quot;&gt;&lt;/a&gt;idea:&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;摘自网上&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&quot;code&quot;&gt;&lt;a href=&quot;#code&quot; class=&quot;headerlink&quot; title=&quot;code:&quot;&gt;&lt;/a&gt;code:&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;public class Solution {
    public boolean wordPattern(String pattern, String str) {
       if (pattern.length() == 0 || str.length() == 0) {
            return false;
        }
        String[] strings = str.split(&amp;quot; &amp;quot;);
        if (pattern.length() != strings.length) {
            return false;
        }
        HashMap&amp;lt;Object, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt; strings.length; i++) {
            if (!Objects.equals(map.put(pattern.charAt(i), i), map.put(strings[i], i))) {
                return false;
            }
        }
        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;[转] (&lt;a href=&quot;https://segmentfault.com/a/1190000003827151&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://segmentfault.com/a/1190000003827151&lt;/a&gt;)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Solution {
    public boolean wordPattern(String pattern, String str) {
        Map&amp;lt;Character, String&amp;gt; map = new HashMap&amp;lt;Character, String&amp;gt;();
        Set&amp;lt;String&amp;gt; set = new HashSet&amp;lt;String&amp;gt;();
        String[] pieces = str.split(&amp;quot; &amp;quot;);
        if(pieces.length != pattern.length()) return false;
        int i = 0;
        for(String s : pieces){
            char p = pattern.charAt(i);
            System.out.println(p);
            // 如果该字符产生过映射
            if(map.containsKey(p)){
                // 且映射的字符串和当前字符串不一样
                if(!s.equals(map.get(p))) return false;
            } else {
            // 如果该字符没有产生过映射
                // 如果当前字符串已经被映射过了
                if(set.contains(s)) return false;
                // 否则新加一组映射
                map.put(p, s);
                set.add(s);
            }
            i++;
        }
        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Algorithm-Description&quot;&gt;&lt;a href=&quot;#Algorithm-Description&quot; class=&quot;headerlink&quot; title=&quot;Algorithm Description&quot;&gt;&lt;/a&gt;Algorithm Description&lt;/
    
    </summary>
    
      <category term="LeetCode" scheme="http://seifzhang.jerrychia.com/categories/LeetCode/"/>
    
    
      <category term="Hash Table" scheme="http://seifzhang.jerrychia.com/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>Coding283_Move_Zeroes</title>
    <link href="http://seifzhang.jerrychia.com/2016/06/21/leetCode-OJ-283/"/>
    <id>http://seifzhang.jerrychia.com/2016/06/21/leetCode-OJ-283/</id>
    <published>2016-06-21T02:52:00.000Z</published>
    <updated>2016-06-23T07:07:54.587Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Algorithm-Description&quot;&gt;&lt;a href=&quot;#Algorithm-Description&quot; class=&quot;headerlink&quot; title=&quot;Algorithm Description&quot;&gt;&lt;/a&gt;Algorithm Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Given an array &lt;code&gt;nums&lt;/code&gt;, write a function to move all &lt;code&gt;0&lt;/code&gt;‘s to the end of it while maintaining the relative order of the non-zero elements.&lt;/p&gt;
&lt;p&gt;For example, given &lt;code&gt;nums = [0, 1, 0, 3, 12]&lt;/code&gt;, after calling your function, &lt;code&gt;nums&lt;/code&gt; should be &lt;code&gt;[1, 3, 12, 0, 0]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;You must do this &lt;strong&gt;in-place&lt;/strong&gt; without making a copy of the array.&lt;/li&gt;
&lt;li&gt;Minimize the total number of operations.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;My-Algorithm&quot;&gt;&lt;a href=&quot;#My-Algorithm&quot; class=&quot;headerlink&quot; title=&quot;My Algorithm&quot;&gt;&lt;/a&gt;My Algorithm&lt;/h2&gt;&lt;h3 id=&quot;idea&quot;&gt;&lt;a href=&quot;#idea&quot; class=&quot;headerlink&quot; title=&quot;idea:&quot;&gt;&lt;/a&gt;idea:&lt;/h3&gt;&lt;hr&gt;
&lt;h3 id=&quot;code&quot;&gt;&lt;a href=&quot;#code&quot; class=&quot;headerlink&quot; title=&quot;code:&quot;&gt;&lt;/a&gt;code:&lt;/h3&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Algorithm-Description&quot;&gt;&lt;a href=&quot;#Algorithm-Description&quot; class=&quot;headerlink&quot; title=&quot;Algorithm Description&quot;&gt;&lt;/a&gt;Algorithm Description&lt;/
    
    </summary>
    
      <category term="LeetCode" scheme="http://seifzhang.jerrychia.com/categories/LeetCode/"/>
    
    
      <category term="Array" scheme="http://seifzhang.jerrychia.com/tags/Array/"/>
    
      <category term="Two Pointers" scheme="http://seifzhang.jerrychia.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>Coding278_First_Bad_Version</title>
    <link href="http://seifzhang.jerrychia.com/2016/06/21/leetCode-OJ-278/"/>
    <id>http://seifzhang.jerrychia.com/2016/06/21/leetCode-OJ-278/</id>
    <published>2016-06-21T02:50:00.000Z</published>
    <updated>2016-06-28T04:57:20.774Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Algorithm-Description&quot;&gt;&lt;a href=&quot;#Algorithm-Description&quot; class=&quot;headerlink&quot; title=&quot;Algorithm Description&quot;&gt;&lt;/a&gt;Algorithm Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.&lt;/p&gt;
&lt;p&gt;Suppose you have &lt;code&gt;n&lt;/code&gt; versions &lt;code&gt;[1, 2, ..., n]&lt;/code&gt; and you want to find out the first bad one, which causes all the following ones to be bad.&lt;/p&gt;
&lt;p&gt;You are given an API &lt;code&gt;bool isBadVersion(version)&lt;/code&gt;which will return whether &lt;code&gt;version&lt;/code&gt; is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;My-Algorithm&quot;&gt;&lt;a href=&quot;#My-Algorithm&quot; class=&quot;headerlink&quot; title=&quot;My Algorithm&quot;&gt;&lt;/a&gt;My Algorithm&lt;/h2&gt;&lt;h3 id=&quot;idea&quot;&gt;&lt;a href=&quot;#idea&quot; class=&quot;headerlink&quot; title=&quot;idea:&quot;&gt;&lt;/a&gt;idea:&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在不破坏原来非0数字的情况下，把0移到数组的最后&lt;br&gt;设两个指针，i从0-nums.length依次为数组赋值，j寻找非0元素&lt;br&gt;能保证顺序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&quot;code&quot;&gt;&lt;a href=&quot;#code&quot; class=&quot;headerlink&quot; title=&quot;code:&quot;&gt;&lt;/a&gt;code:&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;public class Solution {
    public void moveZeroes(int[] nums) {
        int i = 0, j = 0;
        while (j &amp;lt; nums.length) {
            if (nums[j] == 0) {
                j++;
            } else {
                nums[i++] = nums[j++];
            }
        }
        while (i &amp;lt; nums.length) {
            nums[i++] = 0;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Algorithm-Description&quot;&gt;&lt;a href=&quot;#Algorithm-Description&quot; class=&quot;headerlink&quot; title=&quot;Algorithm Description&quot;&gt;&lt;/a&gt;Algorithm Description&lt;/
    
    </summary>
    
      <category term="LeetCode" scheme="http://seifzhang.jerrychia.com/categories/LeetCode/"/>
    
    
      <category term="Binary Search" scheme="http://seifzhang.jerrychia.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>Coding263_Ugly_Number</title>
    <link href="http://seifzhang.jerrychia.com/2016/06/21/leetCode-OJ-263/"/>
    <id>http://seifzhang.jerrychia.com/2016/06/21/leetCode-OJ-263/</id>
    <published>2016-06-21T02:48:00.000Z</published>
    <updated>2016-06-28T04:42:30.374Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Algorithm-Description&quot;&gt;&lt;a href=&quot;#Algorithm-Description&quot; class=&quot;headerlink&quot; title=&quot;Algorithm Description&quot;&gt;&lt;/a&gt;Algorithm Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Write a program to check whether a given number is an ugly number.&lt;/p&gt;
&lt;p&gt;Ugly numbers are positive numbers whose prime factors only include&lt;code&gt;2, 3, 5&lt;/code&gt;. For example, &lt;code&gt;6, 8&lt;/code&gt;are ugly while&lt;code&gt;14&lt;/code&gt;is not ugly since it includes another prime factor &lt;code&gt;7&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Note that &lt;code&gt;1&lt;/code&gt;is typically treated as an ugly number.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;My-Algorithm&quot;&gt;&lt;a href=&quot;#My-Algorithm&quot; class=&quot;headerlink&quot; title=&quot;My Algorithm&quot;&gt;&lt;/a&gt;My Algorithm&lt;/h2&gt;&lt;h3 id=&quot;idea&quot;&gt;&lt;a href=&quot;#idea&quot; class=&quot;headerlink&quot; title=&quot;idea:&quot;&gt;&lt;/a&gt;idea:&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;1是丑数&lt;br&gt;如果一个正整数的质因子只包括2,3,5，那么就是丑数&lt;br&gt;如果一个数如果它能被2整除，我们把它连续除以2；如果能被3整除，就连续除以3；如果能被5整除，就除以连续5。如果最后我们得到的是1，那么这个数就是丑数，否则不是。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&quot;code&quot;&gt;&lt;a href=&quot;#code&quot; class=&quot;headerlink&quot; title=&quot;code:&quot;&gt;&lt;/a&gt;code:&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;public class Solution {
    public boolean isUgly(int num) {
        if (num &amp;lt;= 0) {
            return false;
        }
        while (num % 2 == 0) {
            num = num / 2;
        }
        while (num % 3 == 0) {
            num = num / 3;
        }
        while (num % 5 == 0) {
            num = num / 5;
        }
        return num == 1 ? true : false;
    }
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Algorithm-Description&quot;&gt;&lt;a href=&quot;#Algorithm-Description&quot; class=&quot;headerlink&quot; title=&quot;Algorithm Description&quot;&gt;&lt;/a&gt;Algorithm Description&lt;/
    
    </summary>
    
      <category term="LeetCode" scheme="http://seifzhang.jerrychia.com/categories/LeetCode/"/>
    
    
      <category term="Math" scheme="http://seifzhang.jerrychia.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Coding258_Add_Digits</title>
    <link href="http://seifzhang.jerrychia.com/2016/06/21/leetCode-OJ-258/"/>
    <id>http://seifzhang.jerrychia.com/2016/06/21/leetCode-OJ-258/</id>
    <published>2016-06-21T02:46:00.000Z</published>
    <updated>2016-06-27T06:20:10.048Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Algorithm-Description&quot;&gt;&lt;a href=&quot;#Algorithm-Description&quot; class=&quot;headerlink&quot; title=&quot;Algorithm Description&quot;&gt;&lt;/a&gt;Algorithm Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;For example:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Given &lt;code&gt;num = 38&lt;/code&gt;, the process is like: &lt;code&gt;3 + 8 = 11&lt;/code&gt;, &lt;code&gt;1 + 1 = 2&lt;/code&gt;. Since&lt;code&gt;2&lt;/code&gt; has only one digit, return it.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow up:&lt;/strong&gt;&lt;br&gt;Could you do it without any loop/recursion in O(1) runtime?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hint:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A naive implementation of the above process is trivial. Could you come up with other methods?&lt;/li&gt;
&lt;li&gt;What are all the possible results?&lt;/li&gt;
&lt;li&gt;How do they occur, periodically or randomly?&lt;/li&gt;
&lt;li&gt;You may find this &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_root&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Wikipedia article&lt;/a&gt; useful.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;My-Algorithm&quot;&gt;&lt;a href=&quot;#My-Algorithm&quot; class=&quot;headerlink&quot; title=&quot;My Algorithm&quot;&gt;&lt;/a&gt;My Algorithm&lt;/h2&gt;&lt;h3 id=&quot;idea&quot;&gt;&lt;a href=&quot;#idea&quot; class=&quot;headerlink&quot; title=&quot;idea:&quot;&gt;&lt;/a&gt;idea:&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;总结了两种数字中各位上数字相加的方法&lt;br&gt;总结规律：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1 -2 -3 -4 -5 -6 -7 -8 -9
10-11-12-13-14-15-16-17-18
19-20-21-22-23-24-25-26-27
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&quot;code&quot;&gt;&lt;a href=&quot;#code&quot; class=&quot;headerlink&quot; title=&quot;code:&quot;&gt;&lt;/a&gt;code:&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;public class Solution {
    public int addDigits(int num) {
        if (num &amp;lt; 10)
            return num;
        int ret = 0;
        ret = add(num);
        return addDigits(ret);
    }

    public int add(int num) {
        int sum = 0;
        while (num != 0) {
            sum += num % 10;
            num = num / 10;
        }
        return sum;
    }

    // 另一种使数字中各位上数字相加的方法
    public int add1(int num) {
        String s = String.valueOf(num);
        char[] chs = s.toCharArray();
        int sum = 0;
        for (int i = 0; i &amp;lt; chs.length; i++) {
            sum += chs[i] - &amp;apos;0&amp;apos;;
        }
        return sum;
    }
    //自己做出来的是上面的方法，下面的方法是网上的方法
    public int addDigits1(int num) {
         while(num&amp;gt;=10){  
                num = (num/10)+num%10;  
            }  
            return num;  
    }
    //总结规律：
    //1 -2 -3 -4 -5 -6 -7 -8 -9
    //10-11-12-13-14-15-16-17-18
    //19-20-21-22-23-24-25-26-27
    public int addDigits2(int num) {
        return 1+(num-1)%9;
    }
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Algorithm-Description&quot;&gt;&lt;a href=&quot;#Algorithm-Description&quot; class=&quot;headerlink&quot; title=&quot;Algorithm Description&quot;&gt;&lt;/a&gt;Algorithm Description&lt;/
    
    </summary>
    
      <category term="LeetCode" scheme="http://seifzhang.jerrychia.com/categories/LeetCode/"/>
    
    
      <category term="Math" scheme="http://seifzhang.jerrychia.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Coding257_Binary_Tree_Paths</title>
    <link href="http://seifzhang.jerrychia.com/2016/06/21/leetCode-OJ-257/"/>
    <id>http://seifzhang.jerrychia.com/2016/06/21/leetCode-OJ-257/</id>
    <published>2016-06-21T02:44:00.000Z</published>
    <updated>2016-06-23T08:18:51.427Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Algorithm-Description&quot;&gt;&lt;a href=&quot;#Algorithm-Description&quot; class=&quot;headerlink&quot; title=&quot;Algorithm Description&quot;&gt;&lt;/a&gt;Algorithm Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Given a binary tree, return all root-to-leaf paths.&lt;/p&gt;
&lt;p&gt;For example, given the following binary tree:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   1
 /   \
2     3
\
  5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;All root-to-leaf paths are:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[&amp;quot;1-&amp;gt;2-&amp;gt;5&amp;quot;, &amp;quot;1-&amp;gt;3&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;My-Algorithm&quot;&gt;&lt;a href=&quot;#My-Algorithm&quot; class=&quot;headerlink&quot; title=&quot;My Algorithm&quot;&gt;&lt;/a&gt;My Algorithm&lt;/h2&gt;&lt;h3 id=&quot;idea&quot;&gt;&lt;a href=&quot;#idea&quot; class=&quot;headerlink&quot; title=&quot;idea:&quot;&gt;&lt;/a&gt;idea:&lt;/h3&gt;&lt;hr&gt;
&lt;h3 id=&quot;code&quot;&gt;&lt;a href=&quot;#code&quot; class=&quot;headerlink&quot; title=&quot;code:&quot;&gt;&lt;/a&gt;code:&lt;/h3&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Algorithm-Description&quot;&gt;&lt;a href=&quot;#Algorithm-Description&quot; class=&quot;headerlink&quot; title=&quot;Algorithm Description&quot;&gt;&lt;/a&gt;Algorithm Description&lt;/
    
    </summary>
    
      <category term="LeetCode" scheme="http://seifzhang.jerrychia.com/categories/LeetCode/"/>
    
    
      <category term="Tree" scheme="http://seifzhang.jerrychia.com/tags/Tree/"/>
    
      <category term="Depth-first Search" scheme="http://seifzhang.jerrychia.com/tags/Depth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>Coding242_Valid_Anagram</title>
    <link href="http://seifzhang.jerrychia.com/2016/06/21/leetCode-OJ-242/"/>
    <id>http://seifzhang.jerrychia.com/2016/06/21/leetCode-OJ-242/</id>
    <published>2016-06-21T02:42:00.000Z</published>
    <updated>2016-06-23T06:48:40.418Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Algorithm-Description&quot;&gt;&lt;a href=&quot;#Algorithm-Description&quot; class=&quot;headerlink&quot; title=&quot;Algorithm Description&quot;&gt;&lt;/a&gt;Algorithm Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Given two strings s and t, write a function to determine if t is an anagram of s.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;For example,&lt;/strong&gt;&lt;br&gt;s = “anagram”, t = “nagaram”, return true.&lt;br&gt;s = “rat”, t = “car”, return false.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;br&gt;You may assume the string contains only lowercase alphabets.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow up:&lt;/strong&gt;&lt;br&gt;What if the inputs contain unicode characters? How would you adapt your solution to such case?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;My-Algorithm&quot;&gt;&lt;a href=&quot;#My-Algorithm&quot; class=&quot;headerlink&quot; title=&quot;My Algorithm&quot;&gt;&lt;/a&gt;My Algorithm&lt;/h2&gt;&lt;h3 id=&quot;idea&quot;&gt;&lt;a href=&quot;#idea&quot; class=&quot;headerlink&quot; title=&quot;idea:&quot;&gt;&lt;/a&gt;idea:&lt;/h3&gt;&lt;hr&gt;
&lt;h3 id=&quot;code&quot;&gt;&lt;a href=&quot;#code&quot; class=&quot;headerlink&quot; title=&quot;code:&quot;&gt;&lt;/a&gt;code:&lt;/h3&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Algorithm-Description&quot;&gt;&lt;a href=&quot;#Algorithm-Description&quot; class=&quot;headerlink&quot; title=&quot;Algorithm Description&quot;&gt;&lt;/a&gt;Algorithm Description&lt;/
    
    </summary>
    
      <category term="LeetCode" scheme="http://seifzhang.jerrychia.com/categories/LeetCode/"/>
    
    
      <category term="Hash Table" scheme="http://seifzhang.jerrychia.com/tags/Hash-Table/"/>
    
      <category term="Sort" scheme="http://seifzhang.jerrychia.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>Coding237_Delete_Node_in_a_Linked_List</title>
    <link href="http://seifzhang.jerrychia.com/2016/06/21/leetCode-OJ-237/"/>
    <id>http://seifzhang.jerrychia.com/2016/06/21/leetCode-OJ-237/</id>
    <published>2016-06-21T02:40:00.000Z</published>
    <updated>2016-06-27T05:20:07.870Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Algorithm-Description&quot;&gt;&lt;a href=&quot;#Algorithm-Description&quot; class=&quot;headerlink&quot; title=&quot;Algorithm Description&quot;&gt;&lt;/a&gt;Algorithm Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.&lt;/p&gt;
&lt;p&gt;Supposed the linked list is &lt;code&gt;1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4&lt;/code&gt;and you are given the third node with value 3, the linked list should become&lt;code&gt;1 -&amp;gt; 2 -&amp;gt; 4&lt;/code&gt;after calling your function.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;My-Algorithm&quot;&gt;&lt;a href=&quot;#My-Algorithm&quot; class=&quot;headerlink&quot; title=&quot;My Algorithm&quot;&gt;&lt;/a&gt;My Algorithm&lt;/h2&gt;&lt;h3 id=&quot;idea&quot;&gt;&lt;a href=&quot;#idea&quot; class=&quot;headerlink&quot; title=&quot;idea:&quot;&gt;&lt;/a&gt;idea:&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;删除单链表中的一个节点，只给出要删除的节点，没有别的信息。并且该节点不是最后一个节点。&lt;br&gt;所以把要删除的节点与下一节点交换，删除下一节点就可以了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&quot;code&quot;&gt;&lt;a href=&quot;#code&quot; class=&quot;headerlink&quot; title=&quot;code:&quot;&gt;&lt;/a&gt;code:&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public void deleteNode(ListNode node) {
        if (node == null || node.next == null) {
            return;
        }
        node.val = node.next.val;
        node.next = node.next.next;
    }
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Algorithm-Description&quot;&gt;&lt;a href=&quot;#Algorithm-Description&quot; class=&quot;headerlink&quot; title=&quot;Algorithm Description&quot;&gt;&lt;/a&gt;Algorithm Description&lt;/
    
    </summary>
    
      <category term="LeetCode" scheme="http://seifzhang.jerrychia.com/categories/LeetCode/"/>
    
    
      <category term="LinkedList" scheme="http://seifzhang.jerrychia.com/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>Coding235_Lowest_Common_Ancestor_of_a_Binary Search Tree</title>
    <link href="http://seifzhang.jerrychia.com/2016/06/21/leetCode-OJ-235/"/>
    <id>http://seifzhang.jerrychia.com/2016/06/21/leetCode-OJ-235/</id>
    <published>2016-06-21T02:38:00.000Z</published>
    <updated>2016-06-25T13:22:44.052Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Algorithm-Description&quot;&gt;&lt;a href=&quot;#Algorithm-Description&quot; class=&quot;headerlink&quot; title=&quot;Algorithm Description&quot;&gt;&lt;/a&gt;Algorithm Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.&lt;/p&gt;
&lt;p&gt;According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     _______6______
    /              \
 ___2__          ___8__
/      \        /      \
0      _4       7       9
      /  \
      3   5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;My-Algorithm&quot;&gt;&lt;a href=&quot;#My-Algorithm&quot; class=&quot;headerlink&quot; title=&quot;My Algorithm&quot;&gt;&lt;/a&gt;My Algorithm&lt;/h2&gt;&lt;h3 id=&quot;idea&quot;&gt;&lt;a href=&quot;#idea&quot; class=&quot;headerlink&quot; title=&quot;idea:&quot;&gt;&lt;/a&gt;idea:&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;注意是&lt;strong&gt;二分查找树&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;二叉查找树或者是一棵空树，或者是具有下列性质的二叉树：&lt;br&gt;（1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；&lt;br&gt;（2）若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；&lt;br&gt;（3）左、右子树也分别为二叉查找树；&lt;br&gt;（4）没有键值相等的节点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先判断入口是否有非法输入。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果某一个root==p || root == q，那么LCA肯定是root（因为是top down，LCA肯定在root所囊括的树上，而root又是p q其中一个节点了，那么另外一个节点肯定在root之下，那么root就是LCA），那么返回root&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果root&amp;lt;min(p, q)，那么LCA肯定在右子树上，那么递归&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果max(p, q)&amp;lt;root，那么LCA肯定在左子树上，那么递归&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果p&amp;lt;root&amp;lt;q，那么root肯定为LCA&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&quot;code&quot;&gt;&lt;a href=&quot;#code&quot; class=&quot;headerlink&quot; title=&quot;code:&quot;&gt;&lt;/a&gt;code:&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null || p == null || q == null) {
            return null;
        }
        if ((root.val - p.val) * (q.val - root.val) &amp;gt;= 0) {
            return root;
        }
        if (root.val &amp;gt;= p.val) {
            return lowestCommonAncestor(root.left, p, q);
        }
        return lowestCommonAncestor(root.right, p, q);
    }
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Algorithm-Description&quot;&gt;&lt;a href=&quot;#Algorithm-Description&quot; class=&quot;headerlink&quot; title=&quot;Algorithm Description&quot;&gt;&lt;/a&gt;Algorithm Description&lt;/
    
    </summary>
    
      <category term="LeetCode" scheme="http://seifzhang.jerrychia.com/categories/LeetCode/"/>
    
    
      <category term="Tree" scheme="http://seifzhang.jerrychia.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>Coding234_Palindrome_Linked_List</title>
    <link href="http://seifzhang.jerrychia.com/2016/06/21/leetCode-OJ-234/"/>
    <id>http://seifzhang.jerrychia.com/2016/06/21/leetCode-OJ-234/</id>
    <published>2016-06-21T02:36:00.000Z</published>
    <updated>2016-06-25T10:46:10.542Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Algorithm-Description&quot;&gt;&lt;a href=&quot;#Algorithm-Description&quot; class=&quot;headerlink&quot; title=&quot;Algorithm Description&quot;&gt;&lt;/a&gt;Algorithm Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Given a singly linked list, determine if it is a palindrome.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow up:&lt;/strong&gt;&lt;br&gt;Could you do it in O(n) time and O(1) space?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;My-Algorithm&quot;&gt;&lt;a href=&quot;#My-Algorithm&quot; class=&quot;headerlink&quot; title=&quot;My Algorithm&quot;&gt;&lt;/a&gt;My Algorithm&lt;/h2&gt;&lt;h3 id=&quot;idea&quot;&gt;&lt;a href=&quot;#idea&quot; class=&quot;headerlink&quot; title=&quot;idea:&quot;&gt;&lt;/a&gt;idea:&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;判断一个单向链表是否是回文链表，要求O（n）的时间复杂度和O（1）的空间复杂度。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;遍历整个链表，将链表每个节点的值记录在数组中，再判断数组是不是一个回文数组，时间复杂度为O（n），空间复杂度也为O（n）。&lt;/li&gt;
&lt;li&gt;利用栈先进后出的性质，将链表前半段压入栈中，再逐个弹出与链表后半段比较。时间复杂度O（n），但仍然需要n/2的栈空间，空间复杂度为O（n）。&lt;/li&gt;
&lt;li&gt;反转链表法，将链表后半段原地翻转，再将前半段、后半段依次比较，判断是否相等，时间复杂度O（n），空间复杂度为O（1）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&quot;code&quot;&gt;&lt;a href=&quot;#code&quot; class=&quot;headerlink&quot; title=&quot;code:&quot;&gt;&lt;/a&gt;code:&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
 // 此法不对，因为是在一个单链表上操作；p2 = reverseList(head);相当于是在另一个链表上操作了
    public boolean isPalindrome1(ListNode head) {
        if (head == null)
            return true;
        ListNode p1 = head;
        ListNode p2 = null;
        p2 = reverseList(head);
        while ((p1.next != null) &amp;amp;&amp;amp; (p2.next != null)) {
            if (p1.val != p2.val) {
                return false;
            }
            p1 = p1.next;
            p2 = p2.next;
        }
        return true;
    }

    public boolean isPalindrome(ListNode head) {
        if (head == null)
            return true;
        // 1、寻找中间的指针start--mid--end，使用快慢指针
        ListNode slow = head;
        ListNode fast = head;
        ListNode mid = null;
        while (fast != null &amp;amp;&amp;amp; fast.next != null) {// 循环条件缺一不可（缺少程序会崩溃），链表节点个数可能为为奇数或偶数
            slow = slow.next;// 慢指针走一步
            fast = fast.next.next;// 快指针走两步
        }
        mid = slow;
        // 2、然后把中间到最后的链表反转start--end--mid(mid_new)
        ListNode mid_new = reverseList(mid);
        // 3、然后start--mid_new与end--mid_new比较
        while (mid_new != null &amp;amp;&amp;amp; head != null) {
            if (mid_new.val != head.val) {
                return false;
            }
            mid_new = mid_new.next;
            head = head.next;
        }
        return true;
    }

    public ListNode reverseList(ListNode head) {
        ListNode preHead = new ListNode(-1);
        preHead.next = head;
        ListNode tmp, p;
        if (head == null) {
            return null;
        }
        tmp = preHead.next;
        while (tmp.next != null) {
            p = tmp.next;
            tmp.next = p.next;
            p.next = preHead.next;
            preHead.next = p;
        }
        return preHead.next;
    }

    public ListNode reverseList1(ListNode head) {
        ListNode prev = null;
        while (head != null) {
            ListNode tmp = head.next;
            head.next = prev;
            prev = head;
            head = tmp;
        }
        return prev;
    }
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Algorithm-Description&quot;&gt;&lt;a href=&quot;#Algorithm-Description&quot; class=&quot;headerlink&quot; title=&quot;Algorithm Description&quot;&gt;&lt;/a&gt;Algorithm Description&lt;/
    
    </summary>
    
      <category term="LeetCode" scheme="http://seifzhang.jerrychia.com/categories/LeetCode/"/>
    
    
      <category term="Two Pointers" scheme="http://seifzhang.jerrychia.com/tags/Two-Pointers/"/>
    
      <category term="LinkedList" scheme="http://seifzhang.jerrychia.com/tags/LinkedList/"/>
    
  </entry>
  
</feed>
